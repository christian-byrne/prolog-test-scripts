

## Question 01

> Consider the two rules below for sibling where sibling(X,Y) means that X and Y share at least one parent.
> 
> ```prolog
> sibling(X,Y) :- parent(P,X), parent(P,Y), not(X=Y).
> 
> sibling(X,Y) :- not(X=Y), parent(P,X), parent(P,Y).
> ```
> 
> One of the rules works correctly and the other does not. Tell which rule is correct and explain why it works and the other one does not.

---

The conjunction of the sentences `not(X=y)`, `parent(P,X)`, and `parent(P,Y)` is left-associative and therefore the sentence `not(X=y)` is evaluated first. 

In the case where `X` and `Y` are already instantiated (e.g., with a query like `?- sibling(constant, constant).`), the predicate will work 'correctly.'

However, in the case where either or both of `X` and `Y` are not instantiated (e.g., with a query like `?- sibling(X, Y).`), the sentence `not(X=y)` will always fail. The uninstantiated variable(s) are still free to be bound to any $d \in D$, so the predicate `not(X=Y)` must hold $\forall X, Y \in D$. Since it should always be the case that $\exists X, Y \in D$ such that $X = Y$ (e.g., `not(d, d)`), the predicate `not(X=Y)` will always fail.

`not(X=Y)` when `X` and `Y` are not instantiated is equivalent to "it cannot be proven true that `X=Y` when `X` and `Y` are free to be assigned to any constant in the domain."




## Question 02

> Below is the code we wrote in class for the Man-Wolf-Goat-Cabbage problem. Explain the purpose of each predicate in solving the problem. Note that it is not enough to just repeat what is in the comments. You need to show that you understand the code and what each piece is doing.
> 
> ```prolog
> oppositeSides(e,w).
> oppositeSides(w,e).
> 
> bad([S,O,O,_]) :- oppositeSides(S,O).
> bad([S,_,O,O]) :- oppositeSides(S,O).
> 
> move(nothing,[M,W,G,C],[O,W,G,C]) :- oppositeSides(M,O).
> move(wolf,[M,M,G,C],[O,O,G,C]) :- oppositeSides(M,O).
> move(goat,[M,W,M,C],[O,W,O,C]) :- oppositeSides(M,O).
> move(cabbage,[M,W,G,M],[O,W,G,O]) :- oppositeSides(M,O).
> 
> solution([],[[e,e,e,e]]).
> solution([Move|MovesTail], [Start,End|Tail]) :-
> move(Move,Start,End),
> not(bad(End)),
> solution(MovesTail,[End|Tail]).
> ```


---


